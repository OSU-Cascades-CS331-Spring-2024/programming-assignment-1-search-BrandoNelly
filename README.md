[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-24ddc0f5d75046c5622901739e7c5dd533143b0c8e959d652212380cedb1ea36.svg)](https://classroom.github.com/a/JQF7KaHD)


* Collaboration with Daniel Lounsbury, for providing his dms_to_dd function for converting the cardinal directions of the cities to usable format.

* Search algorithm designs based off pseudocode found in the book Artificial Intelligence: A Modern Approach and their respective wiki and/or geekforgeeks pages.

Project 1 is incomplete, the code will not compile at time of turn in. I unfortunately cannot comment on the results of the optimal search paths found by the agent actions from this program. I will provide what I believe to be the pros and cons of these search algorithms and what the expected outcome possibly should have been.

Breadth First Search is an uninformed but thorough search algorithm. This is useful for exploring the whole span of an explorable graph to determine the optimal path. This will often find a correct optimal path, but this implementation is also costly, requiring the most space out of these searches as all nodes are expanded at each level and added to a maintained nodes list. BFS is also slower compared to the other searches as each node at every level must be explored first before moving to a deeper level.

Depth Limited Search is similar to the traditional DFS(depth limited search) with the added utility of setting the max depth of search traversal. The agent will explore the nodes one level at a time up to the cutoff point. This search is perhaps the most simple of the searches, requiring the least amount of work however it can also be less than optimal if given a large tree to explore with large depths. The idea of this search is to limit the scope of the search within the tree, in hopes that the goal state is not buried too deeply. If the goal state is deeper than the given depth max, then the goal state will not ever be reached. This depth limit can save on space and time complexity but is limited in its utility by nature if not used with care. 

Uniform-Cost Search is a flexible search algorithm that finds an optimal search path by taking into account an assigned cost to the nodes explored. This is effective for finding an optimal path but can somewhat more complicated to implement. The agent needs to be able to calculate the distance between the maintained nodes and the cost of paths between each nodes neighors. IT does this by utilizing a priority queue data structure to maintain the adding and removal of nodes to its maintained list as it traverses the problem set. The more complex the paths and their costs and higher the branching factor the more costly it will be to calculate all of the paths and compare to find the optimal one. The space required for this implementation is higher than the previously mentioned BFS and DLS, and the more complex the problem set is will slow the searches performance, but it is excellent for finding a true correct optimal path providing the use of non-negatives.

A* Search is an informed search that acts as an extension to Uniform-Cost Search. A* takes advantage of a heuristic for estimating the best path forward to the goal state. By evaluating the next lowest path cost of exanded successors from a particular node in the set, and remembering the cost of paths explored, the agent can take estimated decisions on the best path forward toward a goal state. This is the most complex algorithm of the set in this project. The requirement of an admissable heuristic with determining cost forward from the remaining cost not explored from the cost already explored can be difficult to implement. A* should be the most consistently optimal search compared to uninformed searches like UCS and DLS. 